# 使用macro_rules!来创建宏

- 宏系统，可进行元编程
- 宏并不产生函数而是展开成源码，并和程序的其余部分一起被编译

- rust的宏会展开成抽象语法树AST，而不是像字符串预处理那样直接替换成代码，避免产生无法预料的优先权错误

- macro_rules!宏来创建宏

- 为什么使用宏？
  - 不写重复代码
  - 领域专用语言
  - 可变接口，有时需要能够接受不定数目的接口

- 基本概念
  - 模式与指示符
  - 重载
  - 重复

# 指示符
- 宏的参数使用一个$作为前缀，并使用一个指示符来注明类型

- 全部指示符：
  - block
  - expr用于表达式
  - ident用于变量名或函数
  - item
  - pat（模式pattern）
  - path
  - stmt（语句statement）
  - tt（标记树 token tree）
  - ty（类型 type）

# 重载

- 宏可以重载，从而接受不同的参数组合
- 在这方面，macro_rules!类似于匹配match代码

# 重复

- 宏在参数列表中可以用+来表示一个参数可能出现一次或多次，使用*表示该参数可能出现零次或多次

# DRY不写重复代码
- 通过提取函数或测试集的公共部分，宏可以让你写出DRY的代码

# DSL领域专用语言

- DSL 是 Rust 的宏中集成的微型 “语言”。
- 这种语言是完全合法的，因为宏系统会把它转换 成普通的 Rust 语法树，它只不过看起来像是另一种语言而已。
- 这就允许你为一些特定功能 创造一套简洁直观的语法（当然是有限制的）

# 可变参数接口
- 可变参数接口可以接受任意数目的采纳数