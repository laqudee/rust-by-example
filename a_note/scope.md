# 作用域规则

- 作用域在所有权ownership、借用bnorrow、生命周期lifetime中起着重要作用。
- 也就说作用域告诉编译器什么时候借用是合法的，什么时候资源可以释放，以及变量何时被创建销毁

# RAII

- rust的变量不只是在栈中保存数据，他们还占有资源，比如`Box<T>`占有堆heap中的内存
- rust强制实行资源获取即初始化，所以任何对象在离开作用域时，他的析构函数被调用，他所占的资源被释放

- 避免内存泄漏

- rust中的析构函数通过Drop trait提供。

# 所有权和移动
- 因为变量要负责释放他们所拥抱的资源，所以资源只能拥有一个所有者

- 进行赋值或通过值来传递函数参数的时候，资源的所有权会阿生转移，这就是移动

- 避免空指针

# 可变性
- 当所有权转移，数据的可变性可能发生改变

# 部分移动
- 在单个变量的解构内，可以同时使用by-move和by-reference模式绑定。
- 将导致变量的部分移动。
- 这种情况下，后面不能整体使用父级变量，但是仍然可用使用只引用（而不移动）的部分

# 借用
- &T
- 编译器通过借用检查，静态地保证了引用总是指向有效的对象，也就是说当存在引用指向一个对象时，该对象不能被销毁

# 可变性
- &mut T
- 借用者可以读写数据

# 别名使用
- 数据可以多次不可变借用，但是在不可变借用的同时，原始数据不能使用可变借用。
- 同一时间内只允许一次可变使用，仅当最后一次使用可变引用之后，原始数据才可以再次借用

# ref 模式
- 在通过let绑定来进行模式匹配或解构时，ref关键字可用来创建结构体/元组的字段的引用